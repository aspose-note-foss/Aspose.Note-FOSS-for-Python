# Запись (writer) — базовые правила: append-only и транзакции (2.3.3)

Формат `[MS-ONESTORE]` рассчитан на «append-only» модификации:

- существующие `FileNode` в списках **нельзя** изменять или удалять;
- обновления реализуются добавлением новых `FileNode` (и иногда новых file node lists);
- консистентность обеспечивается `Transaction Log` и коммитом через `Header.cTransactionsInLog`.

## 1) Общая стратегия записи

Минимально безопасная стратегия:

1. Не изменять уже достижимые (reachable) и ранее «закоммиченные» данные, **кроме**:
   - полей `Header`, которые по спецификации меняются при коммите;
   - неиспользуемых storage blocks (unused blocks) и padding/ignored-областей, которые не влияют на интерпретацию ранее закоммиченных структур.
2. Все новые структуры писать в «хвост» файла или в блоки из free list.
3. Обновлять указатели только на уровне «коммита» транзакции.

## 2) Free Chunk List (2.3.2) — аллокация блоков

Для writer вам нужен allocator:

- если `Header.fcrFreeChunkList` отсутствует — используйте стратегию «append only» и просто дописывайте в конец файла;
- если список есть — можете переиспользовать свободные диапазоны.

Правило:

- при записи в блоки из free list, free list MUST быть обновлён, чтобы отражать изменения.

## 3) Transaction Log (2.3.3) — коммит

Транзакция включает:

- добавленные/изменённые file node lists (на практике: добавленные узлы в списки)
- набор `TransactionEntry` записей
- увеличение `Header.cTransactionsInLog` (последний шаг!)

Правило коммита:

- транзакция считается committed только после того, как `Header.cTransactionsInLog` обновлён на новый номер.

Практическая схема:

1. Записать новые `FileNode` и/или новые `FileNodeListFragment` (если расширяете список новым фрагментом).
2. Записать `TransactionEntry` для каждого затронутого `FileNodeListID`:
   - `srcID = FileNodeListID`
   - `TransactionEntrySwitch = новое кол-во FileNode в списке`
3. Записать sentinel `TransactionEntry` с `srcID = 0x00000001`; `TransactionEntrySwitch` SHOULD быть CRC (2.1.2) от всех `TransactionEntry` текущей транзакции.
   - Примечание: запись `0` вместо CRC — это отклонение от рекомендации SHOULD и может не приниматься строгими валидаторами/ридерами.
4. Обновить `Header.cTransactionsInLog` на `old+1`.
5. Обновить `Header.guidDenyReadFileVersion`, если меняется содержимое файла, исключая `Header` и unused blocks (см. 2.3.1).
6. Обновить `Header.guidFileVersion` и инкрементировать `Header.nFileVersionGeneration`.
   - `guidFileVersion` MUST меняться, когда меняется `cTransactionsInLog` и/или `guidDenyReadFileVersion`.

## 4) FileNodeListFragment и расширение списков (2.4.1)

Если вы добавляете узлы в существующий list и он больше не помещается в текущий последний фрагмент:

- добавьте `ChunkTerminatorFND (0x0FF)` в старый фрагмент **только если** вы делаете его *не последним* (то есть добавляете следующий фрагмент); `ChunkTerminatorFND` MUST NOT использоваться в последнем фрагменте списка,
- создайте новый `FileNodeListFragment` (seq+1) в новом блоке,
- пропишите `nextFragment` в старом фрагменте на новый.

Важно:

- `nextFragment` и `footer` читаются по позициям, вычисляемым от размера фрагмента (`cb` ссылки). При записи вы должны сформировать фрагмент так, чтобы эти позиции совпали с ожидаемыми.

