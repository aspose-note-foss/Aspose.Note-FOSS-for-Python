# Бинарный ридер и битовые поля

Формат `[MS-ONESTORE]` — little-endian, выравнивание 1 байт, много битовых полей и «размер задаётся внешней ссылкой» (chunk reference). Надёжный `BinaryReader` — критично важен.

## 1) Требования к ридеру

Минимальные возможности:

- чтение `u8/u16/u32/u64` little-endian;
- чтение «куска» байт по `(offset, size)` без смещения общего курсора (random access);
- безопасное чтение: везде проверки на выход за пределы файла;
- чтение GUID (16 байт, как bytes; форматирование в строку — отдельным слоем);
- чтение битовых полей из `u32`/`u64` с точным контролем ширины.

## 2) Рекомендованный интерфейс

Сделайте два уровня API:

- `reader` для последовательного чтения (cursor-based)
- `view(offset, size)` возвращает новый `reader` поверх среза (для структур, на которые указывает `fcr/ref`)

Ожидаемые примитивы:

- `read_u32()`, `read_u64()`, `read_bytes(n)`, `tell()`, `seek(pos)`
- `read_u32_bits(widths)` где `widths = [w1, w2, ...]` и извлечение идёт LSB-first (как в `BinaryReader.unpack_bits(...)`).

Важно: текущая реализация возвращает только значения (без имён полей); имена остаются на стороне вызывающего кода.

## 3) Битовые поля: практический шаблон

В `[MS-ONESTORE]` поля часто описаны как `X (N bits)`. Самый практичный подход:

1. Читайте целиком базовое слово (`u32` для `FileNode`).
2. Извлекайте битовые поля по маскам/сдвигам в одном месте (таблица).
3. Храните исходное слово для отладки и round-trip тестов.

## 4) Политика ошибок

Заведите:

- `OneStoreFormatError(message, offset)` — для MUST-нарушений;
- warnings через контекст `ParseContext.warn(...)` (по умолчанию копятся в `ctx.warnings`).

Парсер структур должен принимать `ctx: ParseContext` (или совместимый флаг `strict: bool`).

## 5) Контроль размеров структур

Во многих местах размер структуры = `cb` из chunk reference.

Правило реализации:

- каждая функция `parse_X(reader, *, size: int)` должна гарантировать:
  - не читает больше `size`;
  - в конце либо `reader.tell() == start + size`, либо оставляет «padding/ignored» строго внутри `size`.

Это особенно важно для:

- `FreeChunkListFragment` (массив элементов определяется размером `cb`);
- `FileNodeListFragment` (позиция `nextFragment` вычисляется от размера фрагмента);
- `TransactionLogFragment` (массив `TransactionEntry` (по 8 байт) + опциональный хвост `nextFragment` (12 байт); если фрагмент содержит последнюю транзакцию, `nextFragment` не используется и MUST be ignored).
