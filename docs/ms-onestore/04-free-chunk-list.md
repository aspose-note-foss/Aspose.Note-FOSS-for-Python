# Free Chunk List (2.3.2): список свободных блоков

Free Chunk List нужен главным образом для **записи/дефрагментации**, но для ридера полезен как:

- источник информации о «неиспользуемых» диапазонах (помогает диагностике);
- дополнительная валидация chunk references.

## FreeChunkListFragment (2.3.2.1)

Поля:

- `crc: u32` — CRC поля `fcrFreeChunk` (то есть CRC от байт всего массива `fcrFreeChunk[]`, см. 2.1.2)
- `fcrNextChunk: FileChunkReference64x32` — ссылка на следующий фрагмент или `fcrNil`
- `fcrFreeChunk[]: FileChunkReference64[]` — массив свободных диапазонов

Размер массива:

Спецификация: число элементов = `(cb - 16) / 16`, где `cb` — размер текущего фрагмента, полученный из chunk reference, который на него указывает.

Реализация:

1. Откройте `view(stp, cb)` по `Header.fcrFreeChunkList`.
2. Прочитайте `crc`, затем `fcrNextChunk`.
3. Вычислите `n = (cb - 16) // 16`, проверьте что `(cb - 16) % 16 == 0` (иначе повреждение).
4. Прочитайте `n` элементов `FileChunkReference64`.
5. Если `fcrNextChunk != fcrNil` — повторите для следующего фрагмента (по `stp/cb`).

CRC:

- вычисление CRC зависит от типа файла (`.one` / `.onetoc2`);
- CRC считается по полю `fcrFreeChunk` «как по массиву байт» (на практике: сериализованные 16 байт каждого элемента подряд, без `crc` и без `fcrNextChunk`).

Для read-only ридера достаточно:

- уметь пройти цепочку фрагментов;
- уметь извлечь список свободных диапазонов (без строгой CRC-проверки, если вы ещё не сделали CRC-модуль).
